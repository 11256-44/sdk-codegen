"use strict";
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 Looker Data Sciences, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var sdkModels_1 = require("./sdkModels");
var utils_1 = require("./utils");
var CodeGen = /** @class */ (function () {
    function CodeGen(api, versions) {
        this.api = api;
        this.versions = versions;
        this.needsRequestTypes = false;
        this.willItStream = false;
        this.codePath = './';
        this.packagePath = 'looker';
        this.packageName = 'LookerSDK';
        this.environmentPrefix = this.packageName.toUpperCase();
        this.itself = '';
        this.fileExtension = '.code';
        this.argDelimiter = ', ';
        this.paramDelimiter = ',\n';
        this.propDelimiter = ',\n';
        this.indentStr = '  ';
        this.commentStr = '// ';
        this.nullStr = 'null';
        this.endTypeStr = '';
        this.transport = 'rtl';
        this.apiVersion = '';
        this.apiRef = '';
        this.apiPath = '';
        if (versions && versions.apiVersion) {
            this.apiVersion = versions.apiVersion;
            this.apiRef = this.apiVersion.replace('.', '');
            this.apiPath = "/" + this.apiVersion;
            this.packageName = this.supportsMultiApi() ? "Looker" + this.apiRef + "SDK" : "LookerSDK";
            this.packagePath += this.apiPath;
        }
    }
    /**
     * Returns true if the SDK supports multiple API versions of models
     * @returns {boolean} True if multi-API is supported
     */
    CodeGen.prototype.supportsMultiApi = function () {
        // Currently, all but Swift support multiple APIs
        return true;
    };
    // @ts-ignore
    CodeGen.prototype.streamsPrologue = function (indent) {
        return '';
    };
    CodeGen.prototype.warnEditing = function () {
        var _a;
        return 'NOTE: Do not edit this file generated by Looker SDK Codegen'
            + (this.versions ? " for Looker " + ((_a = this.versions) === null || _a === void 0 ? void 0 : _a.lookerVersion) + " API " + this.apiVersion : '');
    };
    // @ts-ignore
    CodeGen.prototype.streamerSignature = function (indent, method) {
        return '';
    };
    // Only implement this method for languages that have explicit streaming methods declared
    // @ts-ignore
    CodeGen.prototype.declareStreamer = function (indent, method) {
        return '';
    };
    CodeGen.prototype.bumper = function (indent) {
        return indent + this.indentStr;
    };
    CodeGen.prototype.describeProperty = function (property) {
        return "" + property.description + (property.readOnly ? ' (read-only)' : '');
    };
    CodeGen.prototype.sdkFileName = function (baseFileName) {
        return this.fileName("sdk/" + this.apiVersion + "/" + baseFileName);
    };
    CodeGen.prototype.fileName = function (base) {
        return "" + this.codePath + this.packagePath + "/" + base + this.fileExtension;
    };
    CodeGen.prototype.comment = function (indent, description) {
        return utils_1.commentBlock(description, indent, this.commentStr);
    };
    CodeGen.prototype.commentHeader = function (indent, text) {
        return text ? this.comment(indent, text) + "\n" : '';
    };
    CodeGen.prototype.declareParameters = function (indent, params) {
        var _this = this;
        var items = [];
        if (params)
            params.forEach(function (p) { return items.push(_this.declareParameter(indent, p)); });
        return items.join(this.paramDelimiter);
    };
    CodeGen.prototype.declareConstructorArg = function (indent, property) {
        return "" + indent + property.name + (property.nullable ? ' = ' + this.nullStr : '');
    };
    CodeGen.prototype.it = function (value) {
        return this.itself ? this.itself + "." + value : value;
    };
    CodeGen.prototype.declareType = function (indent, type) {
        var _this = this;
        var bump = this.bumper(indent);
        var props = [];
        // TODO skip read-only properties when we correctly tag read-only attributes
        Object.values(type.properties)
            .forEach(function (prop) { return props.push(_this.declareProperty(bump, prop)); });
        return this.typeSignature(indent, type)
            + props.join(this.propDelimiter)
            + this.construct(indent, type)
            + ("" + (this.endTypeStr ? indent : '') + this.endTypeStr);
    };
    CodeGen.prototype.argGroup = function (indent, args, prefix) {
        prefix = prefix || '';
        return args && args.length !== 0 ? indent + "[" + prefix + args.join(this.argDelimiter + prefix) + "]" : this.nullStr;
    };
    CodeGen.prototype.argList = function (indent, args, prefix) {
        prefix = prefix || '';
        return args && args.length !== 0 ? "" + indent + prefix + args.join(this.argDelimiter + prefix) : this.nullStr;
    };
    // this is a builder function to produce arguments with optional null place holders but no extra required optional arguments
    CodeGen.prototype.argFill = function (current, args) {
        if ((!current) && args.trim() === this.nullStr) {
            // Don't append trailing optional arguments if none have been set yet
            return '';
        }
        return "" + args + (current ? this.argDelimiter : '') + current;
    };
    // @ts-ignore
    CodeGen.prototype.httpPath = function (path, prefix) {
        return path;
    };
    // build the http argument list from back to front, so trailing undefined arguments
    // can be omitted. Path arguments are resolved as part of the path parameter to general
    // purpose API method call
    // e.g.
    //   {queryArgs...}, bodyArg, {headerArgs...}, {cookieArgs...}
    //   {queryArgs...}, null, null, {cookieArgs...}
    //   null, bodyArg
    //   {queryArgs...}
    CodeGen.prototype.httpArgs = function (indent, method) {
        var result = this.argFill('', this.argGroup(indent, method.cookieArgs));
        result = this.argFill(result, this.argGroup(indent, method.headerArgs));
        result = this.argFill(result, method.bodyArg ? method.bodyArg : this.nullStr);
        result = this.argFill(result, this.argGroup(indent, method.queryArgs));
        return result;
    };
    // @ts-ignore
    CodeGen.prototype.errorResponses = function (indent, method) {
        var results = method.errorResponses
            .map(function (r) { return "" + r.type.name; });
        return results.join(', ');
    };
    CodeGen.prototype.httpCall = function (indent, method) {
        var bump = indent + this.indentStr;
        var args = this.httpArgs(bump, method);
        var errors = "(" + this.errorResponses(indent, method) + ")";
        return indent + "return " + this.it(this.transport) + "." + method.httpMethod.toLowerCase() + "(" + errors + ", \"" + method.endpoint + "\"" + (args ? ', ' + args : '') + ")";
    };
    // @ts-ignore
    CodeGen.prototype.streamCall = function (indent, method) {
        return '';
    };
    CodeGen.prototype.useRequest = function (method) {
        if (!this.needsRequestTypes)
            return false;
        var body = method.bodyParams[0];
        /**
         *
         * @type {number} if the body parameter is specified and is optional, at least 2 optional parameters are required
         */
        var offset = (body && body.required === false) ? 1 : 0;
        var result = method.optionalParams.length - offset > 1;
        return result;
    };
    // Looks up or dynamically creates the request type for this method based
    // on rules for creating request types at the IApiModel implementation level
    // If no request type is required, no request type is created or referenced
    CodeGen.prototype.requestTypeName = function (method) {
        if (!this.useRequest(method))
            return '';
        var request = this.api.getRequestType(method);
        if (!request)
            return '';
        request.refCount++;
        return request.name;
    };
    // Looks up or dynamically creates the writeable type for this method based
    // on rules for creating writable types at the IApiModel implementation level
    // If no writeable type is required, no writeable type is created or referenced
    CodeGen.prototype.writeableType = function (type) {
        if (!type)
            return undefined;
        var writer = this.api.getWriteableType(type);
        if (!writer)
            return undefined;
        writer.refCount++;
        return writer;
    };
    // @ts-ignore
    CodeGen.prototype.typeNames = function (countError) {
        if (countError === void 0) { countError = true; }
        var items = [];
        if (!this.api)
            return items;
        Object.values(this.api.sortedTypes())
            .filter(function (type) { return (type.refCount > 0) && !(type instanceof sdkModels_1.IntrinsicType); })
            .forEach(function (type) { return items.push(type.name); });
        return items;
    };
    CodeGen.prototype.typeMap = function (type) {
        type.refCount++; // increment refcount
        return { name: type.name || '', default: this.nullStr || '' };
    };
    return CodeGen;
}());
exports.CodeGen = CodeGen;
